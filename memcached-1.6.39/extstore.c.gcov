        -:    0:Source:extstore.c
        -:    0:Graph:extstore.gcno
        -:    0:Data:extstore.gcda
        -:    0:Runs:452
        -:    1:/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
        -:    2:
        -:    3:#include "config.h"
        -:    4:// FIXME: config.h?
        -:    5:#include <stdint.h>
        -:    6:#include <stdbool.h>
        -:    7:// end FIXME
        -:    8:#include <stdlib.h>
        -:    9:#include <limits.h>
        -:   10:#include <pthread.h>
        -:   11:#include <sys/types.h>
        -:   12:#include <sys/stat.h>
        -:   13:#include <sys/uio.h>
        -:   14:#include <fcntl.h>
        -:   15:#include <unistd.h>
        -:   16:#include <stdio.h>
        -:   17:#include <string.h>
        -:   18:#include <assert.h>
        -:   19:#include "extstore.h"
        -:   20:
        -:   21:// TODO: better if an init option turns this on/off.
        -:   22:#ifdef EXTSTORE_DEBUG
        -:   23:#define E_DEBUG(...) \
        -:   24:    do { \
        -:   25:        fprintf(stderr, __VA_ARGS__); \
        -:   26:    } while (0)
        -:   27:#else
        -:   28:#define E_DEBUG(...)
        -:   29:#endif
        -:   30:
        -:   31:#define STAT_L(e) pthread_mutex_lock(&e->stats_mutex);
        -:   32:#define STAT_UL(e) pthread_mutex_unlock(&e->stats_mutex);
        -:   33:#define STAT_INCR(e, stat, amount) { \
        -:   34:    pthread_mutex_lock(&e->stats_mutex); \
        -:   35:    e->stats.stat += amount; \
        -:   36:    pthread_mutex_unlock(&e->stats_mutex); \
        -:   37:}
        -:   38:
        -:   39:#define STAT_DECR(e, stat, amount) { \
        -:   40:    pthread_mutex_lock(&e->stats_mutex); \
        -:   41:    e->stats.stat -= amount; \
        -:   42:    pthread_mutex_unlock(&e->stats_mutex); \
        -:   43:}
        -:   44:
        -:   45:typedef struct __store_wbuf {
        -:   46:    struct __store_wbuf *next;
        -:   47:    char *buf;
        -:   48:    char *buf_pos;
        -:   49:    unsigned int free;
        -:   50:    unsigned int size;
        -:   51:    unsigned int offset; /* offset into page this write starts at */
        -:   52:    bool full; /* done writing to this page */
        -:   53:    bool flushed; /* whether wbuf has been flushed to disk */
        -:   54:} _store_wbuf;
        -:   55:
        -:   56:typedef struct _store_page {
        -:   57:    pthread_mutex_t mutex; /* Need to be held for most operations */
        -:   58:    uint64_t obj_count; /* _delete can decrease post-closing */
        -:   59:    uint64_t bytes_used; /* _delete can decrease post-closing */
        -:   60:    uint64_t offset; /* starting address of page within fd */
        -:   61:    unsigned int version;
        -:   62:    unsigned int refcount;
        -:   63:    unsigned int allocated;
        -:   64:    unsigned int written; /* item offsets can be past written if wbuf not flushed */
        -:   65:    unsigned int bucket; /* which bucket the page is linked into */
        -:   66:    unsigned int free_bucket; /* which bucket this page returns to when freed */
        -:   67:    int fd;
        -:   68:    unsigned short id;
        -:   69:    bool active; /* actively being written to */
        -:   70:    bool closed; /* closed and draining before free */
        -:   71:    bool free; /* on freelist */
        -:   72:    _store_wbuf *wbuf; /* currently active wbuf from the stack */
        -:   73:    struct _store_page *next;
        -:   74:} store_page;
        -:   75:
        -:   76:typedef struct store_engine store_engine;
        -:   77:typedef struct {
        -:   78:    pthread_mutex_t mutex;
        -:   79:    pthread_cond_t cond;
        -:   80:    obj_io *queue;
        -:   81:    obj_io *queue_tail;
        -:   82:    store_engine *e;
        -:   83:    unsigned int depth; // queue depth
        -:   84:} store_io_thread;
        -:   85:
        -:   86:// sub-struct for maintenance related tasks.
        -:   87:struct store_maint {
        -:   88:    pthread_mutex_t mutex;
        -:   89:};
        -:   90:
        -:   91:struct store_engine {
        -:   92:    pthread_mutex_t mutex; /* covers internal stacks and variables */
        -:   93:    store_page *pages; /* directly addressable page list */
        -:   94:    _store_wbuf *wbuf_stack; /* wbuf freelist */
        -:   95:    obj_io *io_stack; /* IO's to use with submitting wbuf's */
        -:   96:    store_io_thread *io_threads;
        -:   97:    store_io_thread *bg_thread; /* dedicated thread for write submit / compact ops */
        -:   98:    store_page **page_buckets; /* stack of pages currently allocated to each bucket */
        -:   99:    store_page **free_page_buckets; /* stack of use-case isolated free pages */
        -:  100:    size_t page_size;
        -:  101:    unsigned int version; /* global version counter */
        -:  102:    unsigned int last_io_thread; /* round robin the IO threads */
        -:  103:    unsigned int io_threadcount; /* count of IO threads */
        -:  104:    unsigned int page_count;
        -:  105:    unsigned int page_free; /* unallocated pages */
        -:  106:    unsigned int page_bucketcount; /* count of potential page buckets */
        -:  107:    unsigned int free_page_bucketcount; /* count of free page buckets */
        -:  108:    unsigned int io_depth; /* FIXME: Might cache into thr struct */
        -:  109:    pthread_mutex_t stats_mutex;
        -:  110:    struct extstore_stats stats;
        -:  111:    struct store_maint maint;
        -:  112:};
        -:  113:
        -:  114:// FIXME: code is duplicated from thread.c since extstore.c doesn't pull in
        -:  115:// the memcached ecosystem. worth starting a cross-utility header with static
        -:  116:// definitions/macros?
        -:  117:// keeping a minimal func here for now.
        -:  118:#define THR_NAME_MAXLEN 16
       24:  119:static void thread_setname(pthread_t thread, const char *name) {
      24*:  120:assert(strlen(name) < THR_NAME_MAXLEN);
        -:  121:#if defined(__linux__) && defined(HAVE_PTHREAD_SETNAME_NP)
       24:  122:pthread_setname_np(thread, name);
        -:  123:#endif
       24:  124:}
        -:  125:#undef THR_NAME_MAXLEN
        -:  126:
       72:  127:static _store_wbuf *wbuf_new(size_t size) {
       72:  128:    _store_wbuf *b = calloc(1, sizeof(_store_wbuf));
       72:  129:    if (b == NULL)
        -:  130:        return NULL;
       72:  131:    b->buf = calloc(size, sizeof(char));
       72:  132:    if (b->buf == NULL) {
    #####:  133:        free(b);
    #####:  134:        return NULL;
        -:  135:    }
       72:  136:    b->buf_pos = b->buf;
       72:  137:    b->free = size;
       72:  138:    b->size = size;
       72:  139:    return b;
        -:  140:}
        -:  141:
     1393:  142:static store_io_thread *_get_io_thread(store_engine *e) {
     1393:  143:    int tid = -1;
     1393:  144:    long long int low = LLONG_MAX;
     1393:  145:    pthread_mutex_lock(&e->mutex);
        -:  146:    // find smallest queue. ignoring lock since being wrong isn't fatal.
        -:  147:    // TODO: if average queue depth can be quickly tracked, can break as soon
        -:  148:    // as we see a thread that's less than average, and start from last_io_thread
    1393*:  149:    for (int x = 0; x < e->io_threadcount; x++) {
     1393:  150:        if (e->io_threads[x].depth == 0) {
        -:  151:            tid = x;
        -:  152:            break;
    #####:  153:        } else if (e->io_threads[x].depth < low) {
    #####:  154:                tid = x;
    #####:  155:            low = e->io_threads[x].depth;
        -:  156:        }
        -:  157:    }
     1393:  158:    pthread_mutex_unlock(&e->mutex);
        -:  159:
     1393:  160:    return &e->io_threads[tid];
        -:  161:}
        -:  162:
      182:  163:static uint64_t _next_version(store_engine *e) {
      182:  164:    return e->version++;
        -:  165:}
        -:  166:// internal only method for freeing a page up
        -:  167:static void _free_page(store_engine *e, store_page *p);
        -:  168:
        -:  169:static void *extstore_io_thread(void *arg);
        -:  170:
        -:  171:/* Copies stats internal to engine and computes any derived values */
     2775:  172:void extstore_get_stats(void *ptr, struct extstore_stats *st) {
     2775:  173:    store_engine *e = (store_engine *)ptr;
     2775:  174:    STAT_L(e);
     2775:  175:    memcpy(st, &e->stats, sizeof(struct extstore_stats));
     2775:  176:    STAT_UL(e);
        -:  177:
        -:  178:    // grab pages_free/pages_used
     2775:  179:    pthread_mutex_lock(&e->mutex);
     2775:  180:    st->pages_free = e->page_free;
     2775:  181:    st->pages_used = e->page_count - e->page_free;
     2775:  182:    pthread_mutex_unlock(&e->mutex);
     2775:  183:    st->io_queue = 0;
     5550:  184:    for (int x = 0; x < e->io_threadcount; x++) {
     2775:  185:        pthread_mutex_lock(&e->io_threads[x].mutex);
     2775:  186:        st->io_queue += e->io_threads[x].depth;
     2775:  187:        pthread_mutex_unlock(&e->io_threads[x].mutex);
        -:  188:    }
        -:  189:    // calculate bytes_fragmented.
        -:  190:    // note that open and yet-filled pages count against fragmentation.
     2775:  191:    st->bytes_fragmented = st->pages_used * e->page_size -
     2775:  192:        st->bytes_used;
     2775:  193:}
        -:  194:
     1554:  195:void extstore_get_page_data(void *ptr, struct extstore_stats *st) {
     1554:  196:    store_engine *e = (store_engine *)ptr;
     1554:  197:    pthread_mutex_lock(&e->maint.mutex);
     1554:  198:    struct extstore_page_data *pd = st->page_data;
        -:  199:
    20482:  200:    for (int i = 0; i < e->page_count; i++) {
    18928:  201:        store_page *p = &e->pages[i];
    18928:  202:        pthread_mutex_lock(&p->mutex);
        -:  203:
    18928:  204:        pd[p->id].free_bucket = p->free_bucket;
    18928:  205:        pd[p->id].version = p->version;
    18928:  206:        pd[p->id].bytes_used = p->bytes_used;
    18928:  207:        if (p->active) {
     2306:  208:            pd[p->id].active = true;
        -:  209:        }
    18928:  210:        if (p->active || p->free) {
     9456:  211:            pthread_mutex_unlock(&p->mutex);
     9456:  212:            continue;
        -:  213:        }
     9472:  214:        if (p->obj_count > 0 && !p->closed) {
     9472:  215:            pd[p->id].bucket = p->bucket;
        -:  216:        }
    9472*:  217:        if ((p->obj_count == 0 || p->closed) && p->refcount == 0) {
    #####:  218:            _free_page(e, p);
        -:  219:        }
     9472:  220:        pthread_mutex_unlock(&p->mutex);
        -:  221:    }
        -:  222:
     1554:  223:    pthread_mutex_unlock(&e->maint.mutex);
     1554:  224:}
        -:  225:
        1:  226:const char *extstore_err(enum extstore_res res) {
        1:  227:    const char *rv = "unknown error";
        1:  228:    switch (res) {
    #####:  229:        case EXTSTORE_INIT_BAD_WBUF_SIZE:
    #####:  230:            rv = "page_size must be divisible by wbuf_size";
    #####:  231:            break;
    #####:  232:        case EXTSTORE_INIT_NEED_MORE_WBUF:
    #####:  233:            rv = "wbuf_count must be >= page_buckets";
    #####:  234:            break;
    #####:  235:        case EXTSTORE_INIT_NEED_MORE_BUCKETS:
    #####:  236:            rv = "page_buckets must be > 0";
    #####:  237:            break;
    #####:  238:        case EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT:
    #####:  239:            rv = "page_size and wbuf_size must be divisible by 1024*1024*2";
    #####:  240:            break;
    #####:  241:        case EXTSTORE_INIT_TOO_MANY_PAGES:
    #####:  242:            rv = "page_count must total to < 65536. Increase page_size or lower path sizes";
    #####:  243:            break;
    #####:  244:        case EXTSTORE_INIT_OOM:
    #####:  245:            rv = "failed calloc for engine";
    #####:  246:            break;
        1:  247:        case EXTSTORE_INIT_OPEN_FAIL:
        1:  248:            rv = "failed to open file";
        1:  249:            break;
        -:  250:        case EXTSTORE_INIT_THREAD_FAIL:
        -:  251:            break;
        -:  252:    }
        1:  253:    return rv;
        -:  254:}
        -:  255:
        -:  256:// TODO: #define's for DEFAULT_BUCKET, FREE_VERSION, etc
       13:  257:void *extstore_init(struct extstore_conf_file *fh, struct extstore_conf *cf,
        -:  258:        enum extstore_res *res) {
       13:  259:    int i;
       13:  260:    struct extstore_conf_file *f = NULL;
       13:  261:    pthread_t thread;
        -:  262:
       13:  263:    if (cf->page_size % cf->wbuf_size != 0) {
    #####:  264:        *res = EXTSTORE_INIT_BAD_WBUF_SIZE;
    #####:  265:        return NULL;
        -:  266:    }
        -:  267:    // Should ensure at least one write buffer per potential page
       13:  268:    if (cf->page_buckets > cf->wbuf_count) {
    #####:  269:        *res = EXTSTORE_INIT_NEED_MORE_WBUF;
    #####:  270:        return NULL;
        -:  271:    }
       13:  272:    if (cf->page_buckets < 1) {
    #####:  273:        *res = EXTSTORE_INIT_NEED_MORE_BUCKETS;
    #####:  274:        return NULL;
        -:  275:    }
        -:  276:
        -:  277:    // TODO: More intelligence around alignment of flash erasure block sizes
       13:  278:    if (cf->page_size % (1024 * 1024 * 2) != 0 ||
       13:  279:        cf->wbuf_size % (1024 * 1024 * 2) != 0) {
    #####:  280:        *res = EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT;
    #####:  281:        return NULL;
        -:  282:    }
        -:  283:
       13:  284:    store_engine *e = calloc(1, sizeof(store_engine));
       13:  285:    if (e == NULL) {
    #####:  286:        *res = EXTSTORE_INIT_OOM;
    #####:  287:        return NULL;
        -:  288:    }
        -:  289:
       13:  290:    e->page_size = cf->page_size;
       13:  291:    uint64_t temp_page_count = 0;
       29:  292:    for (f = fh; f != NULL; f = f->next) {
       17:  293:        f->fd = open(f->file, O_RDWR | O_CREAT, 0644);
       17:  294:        if (f->fd < 0) {
    #####:  295:            *res = EXTSTORE_INIT_OPEN_FAIL;
        -:  296:#ifdef EXTSTORE_DEBUG
        -:  297:            perror("extstore open");
        -:  298:#endif
    #####:  299:            free(e);
       1*:  300:            return NULL;
        -:  301:        }
        -:  302:        // use an fcntl lock to help avoid double starting.
       17:  303:        struct flock lock;
       17:  304:        lock.l_type = F_WRLCK;
       17:  305:        lock.l_start = 0;
       17:  306:        lock.l_whence = SEEK_SET;
       17:  307:        lock.l_len = 0;
       17:  308:        if (fcntl(f->fd, F_SETLK, &lock) < 0) {
        1:  309:            *res = EXTSTORE_INIT_OPEN_FAIL;
        1:  310:            free(e);
        1:  311:            return NULL;
        -:  312:        }
       16:  313:        if (ftruncate(f->fd, 0) < 0) {
    #####:  314:            *res = EXTSTORE_INIT_OPEN_FAIL;
    #####:  315:            free(e);
    #####:  316:            return NULL;
        -:  317:        }
        -:  318:
       16:  319:        temp_page_count += f->page_count;
       16:  320:        f->offset = 0;
        -:  321:    }
        -:  322:
       12:  323:    if (temp_page_count >= UINT16_MAX) {
    #####:  324:        *res = EXTSTORE_INIT_TOO_MANY_PAGES;
    #####:  325:        free(e);
    #####:  326:        return NULL;
        -:  327:    }
       12:  328:    e->page_count = temp_page_count;
        -:  329:
       12:  330:    e->pages = calloc(e->page_count, sizeof(store_page));
       12:  331:    if (e->pages == NULL) {
    #####:  332:        *res = EXTSTORE_INIT_OOM;
        -:  333:        // FIXME: loop-close. make error label
    #####:  334:        free(e);
    #####:  335:        return NULL;
        -:  336:    }
        -:  337:
        -:  338:    // interleave the pages between devices
        -:  339:    f = NULL; // start at the first device.
      141:  340:    for (i = 0; i < e->page_count; i++) {
        -:  341:        // find next device with available pages
      135:  342:        while (1) {
        -:  343:            // restart the loop
      135:  344:            if (f == NULL || f->next == NULL) {
        -:  345:                f = fh;
        -:  346:            } else {
       38:  347:                f = f->next;
        -:  348:            }
      135:  349:            if (f->page_count) {
      129:  350:                f->page_count--;
      129:  351:                break;
        -:  352:            }
        -:  353:        }
      129:  354:        pthread_mutex_init(&e->pages[i].mutex, NULL);
      129:  355:        e->pages[i].id = i;
      129:  356:        e->pages[i].fd = f->fd;
      129:  357:        e->pages[i].free_bucket = f->free_bucket;
      129:  358:        e->pages[i].offset = f->offset;
      129:  359:        e->pages[i].free = true;
      129:  360:        f->offset += e->page_size;
        -:  361:    }
        -:  362:
        -:  363:    // free page buckets allows the app to organize devices by use case
       12:  364:    e->free_page_buckets = calloc(cf->page_buckets, sizeof(store_page *));
       12:  365:    e->free_page_bucketcount = cf->page_buckets;
        -:  366:
       12:  367:    e->page_free = e->page_count;
      141:  368:    for (i = e->page_count-1; i >= 0; i--) {
      129:  369:        int fb = e->pages[i].free_bucket;
      129:  370:        e->pages[i].next = e->free_page_buckets[fb];
      129:  371:        e->free_page_buckets[fb] = &e->pages[i];
        -:  372:    }
        -:  373:
        -:  374:    // 0 is magic "page is freed" version
       12:  375:    e->version = 1;
        -:  376:
        -:  377:    // scratch data for stats. TODO: malloc failure handle
       12:  378:    e->stats.page_data =
       12:  379:        calloc(e->page_count, sizeof(struct extstore_page_data));
       12:  380:    e->stats.page_count = e->page_count;
       12:  381:    e->stats.page_size = e->page_size;
        -:  382:
        -:  383:    // page buckets lazily have pages assigned into them
       12:  384:    e->page_buckets = calloc(cf->page_buckets, sizeof(store_page *));
       12:  385:    e->page_bucketcount = cf->page_buckets;
        -:  386:
        -:  387:    // allocate write buffers
        -:  388:    // also IO's to use for shipping to IO thread
       84:  389:    for (i = 0; i < cf->wbuf_count; i++) {
       72:  390:        _store_wbuf *w = wbuf_new(cf->wbuf_size);
       72:  391:        obj_io *io = calloc(1, sizeof(obj_io));
        -:  392:        /* TODO: on error, loop again and free stack. */
       72:  393:        w->next = e->wbuf_stack;
       72:  394:        e->wbuf_stack = w;
       72:  395:        io->next = e->io_stack;
       72:  396:        e->io_stack = io;
        -:  397:    }
        -:  398:
       12:  399:    pthread_mutex_init(&e->mutex, NULL);
       12:  400:    pthread_mutex_init(&e->stats_mutex, NULL);
       12:  401:    pthread_mutex_init(&e->maint.mutex, NULL);
        -:  402:
       12:  403:    e->io_depth = cf->io_depth;
        -:  404:
        -:  405:    // spawn threads
       12:  406:    e->io_threads = calloc(cf->io_threadcount, sizeof(store_io_thread));
       24:  407:    for (i = 0; i < cf->io_threadcount; i++) {
       12:  408:        pthread_mutex_init(&e->io_threads[i].mutex, NULL);
       12:  409:        pthread_cond_init(&e->io_threads[i].cond, NULL);
       12:  410:        e->io_threads[i].e = e;
        -:  411:        // FIXME: error handling
       12:  412:        pthread_create(&thread, NULL, extstore_io_thread, &e->io_threads[i]);
       12:  413:        thread_setname(thread, "mc-ext-io");
        -:  414:    }
       12:  415:    e->io_threadcount = cf->io_threadcount;
        -:  416:
        -:  417:    // dedicated IO thread for certain non-hotpath functions.
       12:  418:    e->bg_thread = calloc(1, sizeof(store_io_thread));
       12:  419:    e->bg_thread->e = e;
       12:  420:    pthread_mutex_init(&e->bg_thread->mutex, NULL);
       12:  421:    pthread_cond_init(&e->bg_thread->cond, NULL);
       12:  422:    pthread_create(&thread, NULL, extstore_io_thread, e->bg_thread);
       12:  423:    thread_setname(thread, "mc-ext-bgio");
        -:  424:
       12:  425:    return (void *)e;
        -:  426:}
        -:  427:
        -:  428:// Call without *e locked, not a fast function.
       57:  429:static void _evict_page(store_engine *e, unsigned int bucket,
        -:  430:        unsigned int free_bucket) {
       57:  431:    struct extstore_stats st;
       57:  432:    st.page_data = calloc(e->page_count, sizeof(struct extstore_page_data));
       57:  433:    extstore_get_page_data(e, &st);
       57:  434:    uint64_t low_version = ULLONG_MAX;
       57:  435:    unsigned int low_page = 0;
        -:  436:
        -:  437:    // find lowest version of anything in free_bucket OR 0
        -:  438:    // unless free_bucket is 0
     1089:  439:    for (int i = 0; i < e->page_count; i++) {
        -:  440:        // must belong to 0 or the requested free_bucket
     1032:  441:        if (st.page_data[i].free_bucket &&
        -:  442:            st.page_data[i].free_bucket != free_bucket) {
      336:  443:            continue;
        -:  444:        }
        -:  445:
        -:  446:        // found a free page, don't evict.
      696:  447:        if (st.page_data[i].version == 0) {
        -:  448:            low_version = ULLONG_MAX;
        -:  449:            break;
        -:  450:        }
        -:  451:
        -:  452:        // find the lowest version.
      696:  453:        if (!st.page_data[i].active &&
        -:  454:                st.page_data[i].version < low_version) {
      104:  455:            low_page = i;
      104:  456:            low_version = st.page_data[i].version;
        -:  457:        }
        -:  458:    }
        -:  459:
       57:  460:    if (low_version != ULLONG_MAX) {
       57:  461:        extstore_evict_page(e, low_page, low_version);
        -:  462:    }
       57:  463:    free(st.page_data);
       57:  464:}
        -:  465:
        -:  466:// call with *e locked
      239:  467:static store_page *_allocate_page(store_engine *e, unsigned int bucket,
        -:  468:        unsigned int free_bucket) {
      239:  469:    E_DEBUG("EXTSTORE: allocating new page [bucket:%u]\n", bucket);
     239*:  470:    assert(!e->page_buckets[bucket] || e->page_buckets[bucket]->allocated == e->page_size);
      239:  471:    store_page *tmp = NULL;
      239:  472:    if (e->free_page_buckets[free_bucket] != NULL) {
     156*:  473:        assert(e->page_free > 0);
      156:  474:        tmp = e->free_page_buckets[free_bucket];
      156:  475:        e->free_page_buckets[free_bucket] = tmp->next;
       83:  476:    } else if (e->free_page_buckets[0] != NULL) {
        -:  477:        // fall back to default bucket.
      26*:  478:        assert(e->page_free > 0);
       26:  479:        tmp = e->free_page_buckets[0];
       26:  480:        e->free_page_buckets[0] = tmp->next;
        -:  481:    }
      182:  482:    if (tmp != NULL) {
      182:  483:        tmp->next = e->page_buckets[bucket];
      182:  484:        e->page_buckets[bucket] = tmp;
      182:  485:        tmp->active = true;
      182:  486:        tmp->free = false;
      182:  487:        tmp->closed = false;
      182:  488:        tmp->version = _next_version(e);
      182:  489:        tmp->bucket = bucket;
      182:  490:        e->page_free--;
      182:  491:        STAT_INCR(e, page_allocs, 1);
        -:  492:    }
        -:  493:
      239:  494:    if (tmp)
        -:  495:        E_DEBUG("EXTSTORE: got page %u [free:%u]\n", tmp->id, e->page_free);
      239:  496:    return tmp;
        -:  497:}
        -:  498:
        -:  499:// call with *p locked. locks *e
      687:  500:static void _allocate_wbuf(store_engine *e, store_page *p) {
      687:  501:    _store_wbuf *wbuf = NULL;
     687*:  502:    assert(!p->wbuf);
      687:  503:    pthread_mutex_lock(&e->mutex);
      687:  504:    if (e->wbuf_stack) {
      687:  505:        wbuf = e->wbuf_stack;
      687:  506:        e->wbuf_stack = wbuf->next;
      687:  507:        wbuf->next = 0;
        -:  508:    }
      687:  509:    pthread_mutex_unlock(&e->mutex);
      687:  510:    if (wbuf) {
      687:  511:        wbuf->offset = p->allocated;
      687:  512:        p->allocated += wbuf->size;
      687:  513:        wbuf->free = wbuf->size;
      687:  514:        wbuf->buf_pos = wbuf->buf;
      687:  515:        wbuf->full = false;
      687:  516:        wbuf->flushed = false;
        -:  517:
      687:  518:        p->wbuf = wbuf;
        -:  519:    }
      687:  520:}
        -:  521:
        -:  522:/* callback after wbuf is flushed. can only remove wbuf's from the head onward
        -:  523: * if successfully flushed, which complicates this routine. each callback
        -:  524: * attempts to free the wbuf stack, which is finally done when the head wbuf's
        -:  525: * callback happens.
        -:  526: * It's rare flushes would happen out of order.
        -:  527: */
      666:  528:static void _wbuf_cb(void *ep, obj_io *io, int ret) {
      666:  529:    store_engine *e = (store_engine *)ep;
      666:  530:    store_page *p = &e->pages[io->page_id];
      666:  531:    _store_wbuf *w = (_store_wbuf *) io->data;
        -:  532:
        -:  533:    // TODO: Examine return code. Not entirely sure how to handle errors.
        -:  534:    // Naive first-pass should probably cause the page to close/free.
      666:  535:    w->flushed = true;
      666:  536:    pthread_mutex_lock(&p->mutex);
     666*:  537:    assert(p->wbuf != NULL && p->wbuf == w);
     666*:  538:    assert(p->written == w->offset);
      666:  539:    p->written += w->size;
      666:  540:    p->wbuf = NULL;
        -:  541:
      666:  542:    if (p->written == e->page_size)
      161:  543:        p->active = false;
        -:  544:
        -:  545:    // return the wbuf
      666:  546:    pthread_mutex_lock(&e->mutex);
      666:  547:    w->next = e->wbuf_stack;
      666:  548:    e->wbuf_stack = w;
        -:  549:    // also return the IO we just used.
      666:  550:    io->next = e->io_stack;
      666:  551:    e->io_stack = io;
      666:  552:    pthread_mutex_unlock(&e->mutex);
      666:  553:    pthread_mutex_unlock(&p->mutex);
      666:  554:}
        -:  555:
        -:  556:/* Wraps pages current wbuf in an io and submits to IO thread.
        -:  557: * Called with p locked, locks e.
        -:  558: */
      666:  559:static void _submit_wbuf(store_engine *e, store_page *p) {
      666:  560:    _store_wbuf *w;
      666:  561:    pthread_mutex_lock(&e->mutex);
      666:  562:    obj_io *io = e->io_stack;
      666:  563:    e->io_stack = io->next;
      666:  564:    pthread_mutex_unlock(&e->mutex);
      666:  565:    w = p->wbuf;
        -:  566:
        -:  567:    // zero out the end of the wbuf to allow blind readback of data.
      666:  568:    memset(w->buf + (w->size - w->free), 0, w->free);
        -:  569:
      666:  570:    io->next = NULL;
      666:  571:    io->mode = OBJ_IO_WRITE;
      666:  572:    io->page_id = p->id;
      666:  573:    io->data = w;
      666:  574:    io->offset = w->offset;
      666:  575:    io->len = w->size;
      666:  576:    io->buf = w->buf;
      666:  577:    io->cb = _wbuf_cb;
        -:  578:
     1332:  579:    extstore_submit_bg(e, io);
      666:  580:}
        -:  581:
        -:  582:/* engine write function; takes engine, item_io.
        -:  583: * fast fail if no available write buffer (flushing)
        -:  584: * lock engine context, find active page, unlock
        -:  585: * if page full, submit page/buffer to io thread.
        -:  586: *
        -:  587: * write is designed to be flaky; if page full, caller must try again to get
        -:  588: * new page. best if used from a background thread that can harmlessly retry.
        -:  589: */
        -:  590:
    69190:  591:int extstore_write_request(void *ptr, unsigned int bucket,
        -:  592:        unsigned int free_bucket, obj_io *io) {
    69190:  593:    store_engine *e = (store_engine *)ptr;
    69190:  594:    store_page *p;
    69190:  595:    int ret = -1;
    69190:  596:    if (bucket >= e->page_bucketcount)
        -:  597:        return ret;
        -:  598:
    69190:  599:    pthread_mutex_lock(&e->mutex);
    69190:  600:    p = e->page_buckets[bucket];
    69190:  601:    if (!p) {
       25:  602:        p = _allocate_page(e, bucket, free_bucket);
        -:  603:    }
    69190:  604:    pthread_mutex_unlock(&e->mutex);
    69190:  605:    if (!p) {
        4:  606:        _evict_page(e, bucket, free_bucket);
        4:  607:        return ret;
        -:  608:    }
        -:  609:
    69186:  610:    pthread_mutex_lock(&p->mutex);
        -:  611:
        -:  612:    // FIXME: can't null out page_buckets!!!
        -:  613:    // page is full, clear bucket and retry later.
    69186:  614:    if (!p->active ||
    69185:  615:            ((!p->wbuf || p->wbuf->full) && p->allocated >= e->page_size)) {
      214:  616:        pthread_mutex_unlock(&p->mutex);
      214:  617:        pthread_mutex_lock(&e->mutex);
      214:  618:        store_page *temp_p = _allocate_page(e, bucket, free_bucket);
      214:  619:        pthread_mutex_unlock(&e->mutex);
      214:  620:        if (!temp_p) {
       53:  621:            _evict_page(e, bucket, free_bucket);
        -:  622:        }
      214:  623:        return ret;
        -:  624:    }
        -:  625:
        -:  626:    // if io won't fit, submit IO for wbuf and find new one.
    68972:  627:    if (p->wbuf && p->wbuf->free < io->len && !p->wbuf->full) {
      666:  628:        _submit_wbuf(e, p);
      666:  629:        p->wbuf->full = true;
        -:  630:    }
        -:  631:
    68972:  632:    if (!p->wbuf && p->allocated < e->page_size) {
      687:  633:        _allocate_wbuf(e, p);
        -:  634:    }
        -:  635:
        -:  636:    // hand over buffer for caller to copy into
        -:  637:    // leaves p locked.
    68972:  638:    if (p->wbuf && !p->wbuf->full && p->wbuf->free >= io->len) {
    62770:  639:        io->buf = p->wbuf->buf_pos;
    62770:  640:        io->page_id = p->id;
    62770:  641:        return 0;
        -:  642:    }
        -:  643:
     6202:  644:    pthread_mutex_unlock(&p->mutex);
        -:  645:    // p->written is incremented post-wbuf flush
     6202:  646:    return ret;
        -:  647:}
        -:  648:
        -:  649:/* _must_ be called after a successful write_request.
        -:  650: * fills the rest of io structure.
        -:  651: */
    62770:  652:void extstore_write(void *ptr, obj_io *io) {
    62770:  653:    store_engine *e = (store_engine *)ptr;
    62770:  654:    store_page *p = &e->pages[io->page_id];
        -:  655:
    62770:  656:    io->offset = p->wbuf->offset + (p->wbuf->size - p->wbuf->free);
    62770:  657:    io->page_version = p->version;
    62770:  658:    p->wbuf->buf_pos += io->len;
    62770:  659:    p->wbuf->free -= io->len;
    62770:  660:    p->bytes_used += io->len;
    62770:  661:    p->obj_count++;
    62770:  662:    STAT_L(e);
    62770:  663:    e->stats.bytes_written += io->len;
    62770:  664:    e->stats.bytes_used += io->len;
    62770:  665:    e->stats.objects_written++;
    62770:  666:    e->stats.objects_used++;
    62770:  667:    STAT_UL(e);
        -:  668:
    62770:  669:    pthread_mutex_unlock(&p->mutex);
    62770:  670:}
        -:  671:
        -:  672:/* engine submit function; takes engine, item_io stack.
        -:  673: * lock io_thread context and add stack
        -:  674: * signal io thread to wake.
        -:  675: * return success.
        -:  676: */
     2236:  677:static int _extstore_submit(void *ptr, obj_io *io, store_io_thread *t) {
     2236:  678:    unsigned int depth = 0;
     2236:  679:    obj_io *tio = io;
     2236:  680:    obj_io *tail = NULL;
     4474:  681:    while (tio != NULL) {
     2238:  682:        tail = tio; // keep updating potential tail.
     2238:  683:        depth++;
     2238:  684:        tio = tio->next;
        -:  685:    }
        -:  686:
     2236:  687:    pthread_mutex_lock(&t->mutex);
        -:  688:
     2236:  689:    t->depth += depth;
     2236:  690:    if (t->queue == NULL) {
     2207:  691:        t->queue = io;
     2207:  692:        t->queue_tail = tail;
        -:  693:    } else {
        -:  694:        // Have to put the *io stack at the end of current queue.
      29*:  695:        assert(tail->next == NULL);
      29*:  696:        assert(t->queue_tail->next == NULL);
       29:  697:        t->queue_tail->next = io;
       29:  698:        t->queue_tail = tail;
        -:  699:    }
        -:  700:
     2236:  701:    pthread_mutex_unlock(&t->mutex);
        -:  702:
        -:  703:    //pthread_mutex_lock(&t->mutex);
     2236:  704:    pthread_cond_signal(&t->cond);
        -:  705:    //pthread_mutex_unlock(&t->mutex);
     2236:  706:    return 0;
        -:  707:}
        -:  708:
     1393:  709:int extstore_submit(void *ptr, obj_io *io) {
     1393:  710:    store_engine *e = (store_engine *)ptr;
     1393:  711:    store_io_thread *t = _get_io_thread(e);
     1393:  712:    return _extstore_submit(ptr, io, t);
        -:  713:}
        -:  714:
      843:  715:int extstore_submit_bg(void *ptr, obj_io *io) {
      843:  716:    store_engine *e = (store_engine *)ptr;
      843:  717:    store_io_thread *t = e->bg_thread;
      843:  718:    return _extstore_submit(ptr, io, t);
        -:  719:}
        -:  720:
        -:  721:/* engine note delete function: takes engine, page id, size?
        -:  722: * note that an item in this page is no longer valid
        -:  723: */
    27287:  724:int extstore_delete(void *ptr, unsigned int page_id, uint64_t page_version,
        -:  725:        unsigned int count, unsigned int bytes) {
    27287:  726:    store_engine *e = (store_engine *)ptr;
        -:  727:    // FIXME: validate page_id in bounds
    27287:  728:    store_page *p = &e->pages[page_id];
    27287:  729:    int ret = 0;
        -:  730:
    27287:  731:    pthread_mutex_lock(&p->mutex);
    27287:  732:    if (!p->closed && p->version == page_version) {
    16795:  733:        if (p->bytes_used >= bytes) {
    16795:  734:            p->bytes_used -= bytes;
        -:  735:        } else {
    #####:  736:            p->bytes_used = 0;
        -:  737:        }
        -:  738:
    16795:  739:        if (p->obj_count >= count) {
    16795:  740:            p->obj_count -= count;
        -:  741:        } else {
    #####:  742:            p->obj_count = 0; // caller has bad accounting?
        -:  743:        }
    16795:  744:        STAT_L(e);
    16795:  745:        e->stats.bytes_used -= bytes;
    16795:  746:        e->stats.objects_used -= count;
    16795:  747:        STAT_UL(e);
        -:  748:
    16795:  749:        if (p->obj_count == 0 && p->refcount == 0 && !p->active) {
       27:  750:            _free_page(e, p);
        -:  751:        }
        -:  752:    } else {
        -:  753:        ret = -1;
        -:  754:    }
    27287:  755:    pthread_mutex_unlock(&p->mutex);
    27287:  756:    return ret;
        -:  757:}
        -:  758:
    15766:  759:int extstore_check(void *ptr, unsigned int page_id, uint64_t page_version) {
    15766:  760:    store_engine *e = (store_engine *)ptr;
    15766:  761:    store_page *p = &e->pages[page_id];
    15766:  762:    int ret = 0;
        -:  763:
    15766:  764:    pthread_mutex_lock(&p->mutex);
    15766:  765:    if (p->version != page_version)
     4264:  766:        ret = -1;
    15766:  767:    pthread_mutex_unlock(&p->mutex);
    15766:  768:    return ret;
        -:  769:}
        -:  770:
        -:  771:/* allows a compactor to say "we're done with this page, kill it." */
       23:  772:void extstore_close_page(void *ptr, unsigned int page_id, uint64_t page_version) {
       23:  773:    store_engine *e = (store_engine *)ptr;
       23:  774:    store_page *p = &e->pages[page_id];
        -:  775:
       23:  776:    pthread_mutex_lock(&p->mutex);
       23:  777:    if (!p->closed && !p->active && p->version == page_version) {
    #####:  778:        p->closed = true;
    #####:  779:        if (p->refcount == 0) {
    #####:  780:            _free_page(e, p);
        -:  781:        }
        -:  782:    }
       23:  783:    pthread_mutex_unlock(&p->mutex);
       23:  784:}
        -:  785:
        -:  786:/* signal that we've forcefully ejected rather than gracefully closed */
       66:  787:void extstore_evict_page(void *ptr, unsigned int page_id, uint64_t page_version) {
       66:  788:    store_engine *e = (store_engine *)ptr;
       66:  789:    store_page *p = &e->pages[page_id];
        -:  790:
       66:  791:    pthread_mutex_lock(&p->mutex);
       66:  792:    if (!p->closed && !p->active && p->version == page_version) {
        -:  793:        E_DEBUG("EXTSTORE: evicting page [%d] [v: %llu]\n",
       66:  794:                p->id, (unsigned long long) p->version);
        -:  795:
       66:  796:        p->closed = true;
       66:  797:        STAT_L(e);
       66:  798:        e->stats.page_evictions++;
       66:  799:        e->stats.objects_evicted += p->obj_count;
       66:  800:        e->stats.bytes_evicted += p->bytes_used;
       66:  801:        STAT_UL(e);
       66:  802:        if (p->refcount == 0) {
       66:  803:            _free_page(e, p);
        -:  804:        }
        -:  805:    }
       66:  806:    pthread_mutex_unlock(&p->mutex);
       66:  807:}
        -:  808:
        -:  809:/* Finds an attached wbuf that can satisfy the read.
        -:  810: * Since wbufs can potentially be flushed to disk out of order, they are only
        -:  811: * removed as the head of the list successfully flushes to disk.
        -:  812: */
        -:  813:// call with *p locked
        -:  814:// FIXME: protect from reading past wbuf
       18:  815:static inline int _read_from_wbuf(store_page *p, obj_io *io) {
       18:  816:    _store_wbuf *wbuf = p->wbuf;
      18*:  817:    assert(wbuf != NULL);
      18*:  818:    assert(io->offset < p->written + wbuf->size);
       18:  819:    if (io->iov == NULL) {
        8:  820:        memcpy(io->buf, wbuf->buf + (io->offset - wbuf->offset), io->len);
        -:  821:    } else {
       10:  822:        int x;
       10:  823:        unsigned int off = io->offset - wbuf->offset;
        -:  824:        // need to loop fill iovecs
      114:  825:        for (x = 0; x < io->iovcnt; x++) {
      104:  826:            struct iovec *iov = &io->iov[x];
      104:  827:            memcpy(iov->iov_base, wbuf->buf + off, iov->iov_len);
      104:  828:            off += iov->iov_len;
        -:  829:        }
        -:  830:    }
       18:  831:    return io->len;
        -:  832:}
        -:  833:
        -:  834:/* engine IO thread; takes engine context
        -:  835: * manage writes/reads
        -:  836: * runs IO callbacks inline after each IO
        -:  837: */
        -:  838:// FIXME: protect from reading past page
       24:  839:static void *extstore_io_thread(void *arg) {
       24:  840:    store_io_thread *me = (store_io_thread *)arg;
       24:  841:    store_engine *e = me->e;
     2232:  842:    while (1) {
     2232:  843:        obj_io *io_stack = NULL;
     2232:  844:        pthread_mutex_lock(&me->mutex);
     2232:  845:        if (me->queue == NULL) {
     2052:  846:            pthread_cond_wait(&me->cond, &me->mutex);
        -:  847:        }
        -:  848:
        -:  849:        // Pull and disconnect a batch from the queue
        -:  850:        // Chew small batches from the queue so the IO thread picker can keep
        -:  851:        // the IO queue depth even, instead of piling on threads one at a time
        -:  852:        // as they gobble a queue.
     2208:  853:        if (me->queue != NULL) {
        -:  854:            int i;
        -:  855:            obj_io *end = NULL;
     2238:  856:            io_stack = me->queue;
        -:  857:            end = io_stack;
     2238:  858:            for (i = 1; i < e->io_depth; i++) {
     2182:  859:                if (end->next) {
       30:  860:                    end = end->next;
        -:  861:                } else {
     2152:  862:                    me->queue_tail = end->next;
     2152:  863:                    break;
        -:  864:                }
        -:  865:            }
     2208:  866:            me->depth -= i;
     2208:  867:            me->queue = end->next;
     2208:  868:            end->next = NULL;
        -:  869:        }
     2208:  870:        pthread_mutex_unlock(&me->mutex);
        -:  871:
     2208:  872:        obj_io *cur_io = io_stack;
     2208:  873:        while (cur_io) {
        -:  874:            // We need to note next before the callback in case the obj_io
        -:  875:            // gets reused.
     2238:  876:            obj_io *next = cur_io->next;
     2238:  877:            int ret = 0;
     2238:  878:            int do_op = 1;
     2238:  879:            store_page *p = &e->pages[cur_io->page_id];
        -:  880:            // TODO: loop if not enough bytes were read/written.
     2238:  881:            switch (cur_io->mode) {
     1572:  882:                case OBJ_IO_READ:
        -:  883:                    // Page is currently open. deal if read is past the end.
     1572:  884:                    pthread_mutex_lock(&p->mutex);
     1572:  885:                    if (!p->free && !p->closed && p->version == cur_io->page_version) {
     1533:  886:                        if (p->active && cur_io->offset >= p->written) {
       18:  887:                            ret = _read_from_wbuf(p, cur_io);
       18:  888:                            do_op = 0;
        -:  889:                        } else {
     1515:  890:                            p->refcount++;
        -:  891:                        }
     1533:  892:                        STAT_L(e);
     1533:  893:                        e->stats.bytes_read += cur_io->len;
     1533:  894:                        e->stats.objects_read++;
     1533:  895:                        STAT_UL(e);
        -:  896:                    } else {
        -:  897:                        do_op = 0;
        -:  898:                        ret = -2; // TODO: enum in IO for status?
        -:  899:                    }
     1572:  900:                    pthread_mutex_unlock(&p->mutex);
     1572:  901:                    if (do_op) {
        -:  902:#if !defined(HAVE_PREAD) || !defined(HAVE_PREADV)
        -:  903:                        // TODO: lseek offset is natively 64-bit on OS X, but
        -:  904:                        // perhaps not on all platforms? Else use lseek64()
        -:  905:                        ret = lseek(p->fd, p->offset + cur_io->offset, SEEK_SET);
        -:  906:                        if (ret >= 0) {
        -:  907:                            if (cur_io->iov == NULL) {
        -:  908:                                ret = read(p->fd, cur_io->buf, cur_io->len);
        -:  909:                            } else {
        -:  910:                                ret = readv(p->fd, cur_io->iov, cur_io->iovcnt);
        -:  911:                            }
        -:  912:                        }
        -:  913:#else
     1515:  914:                        if (cur_io->iov == NULL) {
     2762:  915:                            ret = pread(p->fd, cur_io->buf, cur_io->len, p->offset + cur_io->offset);
        -:  916:                        } else {
      134:  917:                            ret = preadv(p->fd, cur_io->iov, cur_io->iovcnt, p->offset + cur_io->offset);
        -:  918:                        }
        -:  919:#endif
        -:  920:                    }
        -:  921:                    break;
      666:  922:                case OBJ_IO_WRITE:
      666:  923:                    do_op = 0;
        -:  924:                    // FIXME: Should hold refcount during write. doesn't
        -:  925:                    // currently matter since page can't free while active.
      666:  926:                    ret = pwrite(p->fd, cur_io->buf, cur_io->len, p->offset + cur_io->offset);
      666:  927:                    break;
        -:  928:            }
     2238:  929:            if (ret == 0) {
     2238:  930:                E_DEBUG("read returned nothing\n");
        -:  931:            }
        -:  932:
        -:  933:#ifdef EXTSTORE_DEBUG
        -:  934:            if (ret == -1) {
        -:  935:                perror("read/write op failed");
        -:  936:            }
        -:  937:#endif
     2238:  938:            cur_io->cb(e, cur_io, ret);
     2238:  939:            if (do_op) {
     1515:  940:                pthread_mutex_lock(&p->mutex);
     1515:  941:                p->refcount--;
     1515:  942:                pthread_mutex_unlock(&p->mutex);
        -:  943:            }
        -:  944:            cur_io = next;
        -:  945:        }
        -:  946:    }
        -:  947:
        -:  948:    return NULL;
        -:  949:}
        -:  950:
        -:  951:// call with *p locked.
       93:  952:static void _free_page(store_engine *e, store_page *p) {
       93:  953:    store_page *tmp = NULL;
       93:  954:    store_page *prev = NULL;
       93:  955:    E_DEBUG("EXTSTORE: freeing page %u\n", p->id);
       93:  956:    STAT_L(e);
       93:  957:    e->stats.objects_used -= p->obj_count;
       93:  958:    e->stats.bytes_used -= p->bytes_used;
       93:  959:    e->stats.page_reclaims++;
       93:  960:    STAT_UL(e);
       93:  961:    pthread_mutex_lock(&e->mutex);
        -:  962:    // unlink page from bucket list
       93:  963:    tmp = e->page_buckets[p->bucket];
      911:  964:    while (tmp) {
      911:  965:        if (tmp == p) {
       93:  966:            if (prev) {
       93:  967:                prev->next = tmp->next;
        -:  968:            } else {
    #####:  969:                e->page_buckets[p->bucket] = tmp->next;
        -:  970:            }
       93:  971:            tmp->next = NULL;
       93:  972:            break;
        -:  973:        }
      818:  974:        prev = tmp;
      818:  975:        tmp = tmp->next;
        -:  976:    }
        -:  977:    // reset most values
       93:  978:    p->version = 0;
       93:  979:    p->obj_count = 0;
       93:  980:    p->bytes_used = 0;
       93:  981:    p->allocated = 0;
       93:  982:    p->written = 0;
       93:  983:    p->bucket = 0;
       93:  984:    p->active = false;
       93:  985:    p->closed = false;
       93:  986:    p->free = true;
        -:  987:    // add to page stack
       93:  988:    p->next = e->free_page_buckets[p->free_bucket];
       93:  989:    e->free_page_buckets[p->free_bucket] = p;
       93:  990:    e->page_free++;
       93:  991:    E_DEBUG("EXTSTORE: pages free %u\n", e->page_free);
       93:  992:    pthread_mutex_unlock(&e->mutex);
       93:  993:}
